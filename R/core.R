#' Execute some Stata code in a running Stata instance
#' @param id An object of S3 class 'StataID' generated by \code{\link[RStataLink]{startStata}}
#' @param code A Stata code in a string to be executed
#' @param df A data frame to be loaded into Stata before the Stata code is executed (optional)
#' @param import_df Logical: should the resulting Stata dataset be returned?
#'                      Defaults: \code{TRUE} if \code{df} is provided, else \code{FALSE}.
#' @param results NULL or a character vector with either \code{"e"} or \code{"r"} or both of these
#' characters. Default: \code{c("e", "r")} which means that both e-class and r-class Stata results
#' will be imported (stored in e() and r() Stata macros, scalars, matrices respectively). If
#' \code{NULL}, none of these results will be imported.
#' @param timeout Seconds for R to wait for Stata results. Default: infinity.
#' @param preserve_restore Logical: should the Stata code start with \code{preserve} and end with \code{restore}?
#'                         Default: \code{FALSE}.
#' @param cleanup Logical: should the time-stamped temporary files (.do file, .log file, and possible input
#' and output .tsv files) be deleted at the end? Default: \code{TRUE}.
#' @param nolog Logical: should the Stata log be discarded in the returned value? Default: \code{FALSE}.
#' @param future Logical: should this function block R until Stata finishes the job and return what Stata
#' produces (\code{future = FALSE}, default) or should this function send the job to Stata and
#' not make R wait for Stata output (\code{future = TRUE}). In latter case, the Stata output can
#' be obtained with the function \code{\link[RStataLink]{getStataFuture}}.
#' @return
#' If \code{future = FALSE}, a list with:
#' \itemize{
#'          \item \code{log} -- A character vector with Stata display log
#'          if \code{nolog} is \code{FALSE}. May be an empty string if Stata does not finish executing
#'          the code before \code{timeout}.
#'          \item \code{df} -- Optional: a data frame saved by Stata if \code{import_df} is \code{TRUE} and
#'          if it can be read by \code{\link[utils]{read.delim}}, else \code{NULL}
#'          if \code{\link[utils]{read.delim}} returns an error.
#' }
#' If \code{future = TRUE}, an object of S3 class 'StataFuture' to be used by
#' \code{\link[RStataLink]{getStataFuture}}.
#' @export
doInStata <- function(id,
					  code="",
					  df=NULL,
					  import_df=!is.null(df),
					  results=c('e','r'),
					  timeout=Inf,
					  preserve_restore=FALSE,
					  cleanup=TRUE,
					  nolog=FALSE,
					  future=FALSE) {
	stopifnot(class(id)=='StataID',
			  is.character(code),
			  is.data.frame(df) || is.null(df),
			  is.logical(import_df), length(import_df)==1,
			  if (results %>% is.null) TRUE else
			  	all(results %in% c('e','r')),
			  is.numeric(timeout), timeout>=0,
			  is.logical(preserve_restore), length(preserve_restore)==1,
			  is.logical(cleanup), length(cleanup)==1,
			  is.logical(nolog), length(nolog)==1)
	
	path <- id %++% '/'
	time_stamp <- timeStamp()
	logfile <- paste0(path, 'statalog_', names(id), '_', time_stamp, '.log')
	
	import_df_cmd <- ""
	if (!is.null(df)) {
		inputtsvf <- path %++% 'inputdf_' %++% time_stamp %++% '.tsv'
		write.table(df, file=inputtsvf, sep="\t", na="", row.names=FALSE)
		import_df_cmd <- 'qui insheet using "' %++% inputtsvf %++% '", tab names clear \n'
	}
	
	save_result_cmd <- ""
	outputtsvf <- NULL
	if (import_df) {
		outputtsvf <- path %++% 'outputdf_' %++% time_stamp %++% '.tsv'
		save_result_cmd <- 'qui outsheet using "' %++% outputtsvf %++% '", replace \n'
	}
	
	stata_commands <- paste(
		c('tempname log_' %++% names(id),
		  'log using "' %++% logfile %++% '", replace text name(`log_' %++% names(id) %++% '\')',
		  ifelse(preserve_restore, 'preserve', ""),
		  import_df_cmd,
		  'cap noi /*' %++% time_stamp %++% '*/ {', # time stamp to remove from log later
		  code,
		  '} /*' %++% time_stamp %++% '*/', # time stamp to remove from log later
		  ifelse(!is.null(results), 'qui getStataResults ' %++% time_stamp, ""),
		  save_result_cmd,
		  ifelse(preserve_restore, 'restore', ""),
		  'log close `log_' %++% names(id) %++% '\'',
		  '\n'),
		collapse='\n')
	dofile <- path %++% time_stamp %++% '.do'
	cat(stata_commands, file=dofile)
	
	StataFuture <- environment() %>%
		as.list() %>%
		`class<-`('StataFuture')
	if (future) StataFuture else getStataFuture(StataFuture)
}

#' Obtain Stata output from a job previously sent to Stata by \code{\link[RStataLink]{doInStata}}
#' 
#' @param StataFuture An object of S3 class 'StataFuture' produced by
#' \code{\link[RStataLink]{doInStata}}, with argument \code{future = TRUE},
#' when a job was sent to Stata.
#' @return
#' A list with:
#' \itemize{
#'          \item \code{log} -- A character vector with Stata display log
#'          if \code{nolog} in the job request was is \code{FALSE}.
#'          May be an empty string if Stata does not finish executing
#'          the code before the \code{timeout} set in the job.
#'          \item \code{df} -- Optional: a data frame saved by Stata if
#'          \code{import_df} was \code{TRUE} in the job and
#'          if it can be read by \code{\link[utils]{read.delim}}, else \code{NULL}
#'          if \code{\link[utils]{read.delim}} returns an error.
#' }
#' @export
getStataFuture <- function(StataFuture) {
	stopifnot(class(StataFuture)=='StataFuture')
	
	for (n in names(StataFuture))
		assign(n, StataFuture[[n]])  # destructure StataFuture
	# Wait for the Stata log file and output df file (if requested)
	t <- Sys.time() %>% as.numeric
	while (ifelse(import_df, !file.exists(outputtsvf), !file.exists(logfile)) &&
		   Sys.time() %>% as.numeric %>% subtract(t) < timeout) {
		Sys.sleep(.01)
	}
	
	Output <- list()
	repeat {
		Output$log <- tryCatch(readLines(logfile), error = function(e) NULL, warning = function(w) NULL)
		# Wait until the log file is closed by Stata
		if (glob2rx('*' %++% 'log close `log_' %++% names(id) %++% '*') %>%
			grepl(Output$log) %>% any ||
			Sys.time() %>% as.numeric %>% subtract(t) >= timeout) {
			if(length(Output$log)>=10)
				Output$log %<>% extract(10:(length(.)-10)) %>%
				Filter(function(x)
					x!='. ' & !grepl(time_stamp,x),
					.) %>%
				sub(rep.int('-',240) %>% paste(collapse=""),
					rep.int('-',68) %>% paste(collapse=""),
					., fixed=TRUE) else
						Output$log <- ""
					break
		}
		Sys.sleep(.01)
	}
	if (nolog) Output$log <- NULL
	if (!is.null(Output$log)) class(Output$log) <- 'StataLog'
	if (import_df) {
		Output$df <- tryCatch(utils::read.delim(outputtsvf, stringsAsFactors=FALSE, check.names=FALSE),
							  error = function(e) NULL, warning = function(w) NULL)
	}
	
	if (!is.null(results)) {
		resulttsvf <- path %++% 'resultdf_"CLASS"_' %++% time_stamp %++% '.tsv'
		Output$results <- lapply(results, function(x)
			tryCatch(utils::read.delim(resulttsvf %>%
									   	sub('"CLASS"',x,.,fixed=TRUE),
									   stringsAsFactors=FALSE, check.names=FALSE) %>%
					 	dfResultsToList %>%
					 	`class<-`('StataResults') %>%
					 	{if (length(.)==0) NULL else .},
					 error = function(e) NULL, warning = function(w) NULL)) %>%
			set_names(results %++% '_class')
	}
	
	if (cleanup) removeFiles(path, time_stamp)
	Output
}

#' Remove Stata task/job sent to Stata by \code{\link[RStataLink]{doInStata}}
#' 
#' This is done if possible (if not yet executed or started).
#' @param StataFuture An object of S3 class 'StataFuture' produced by
#' \code{\link[RStataLink]{doInStata}}, with argument \code{future = TRUE},
#' when a job was sent to Stata.
#' @export
deleteStataFuture <- function(StataFuture) {
	stopifnot(class(StataFuture)=='StataFuture')
	for (n in names(StataFuture))
		assign(n, StataFuture[[n]])  # destructure StataFuture
	removeFiles(path, time_stamp)
}

#' Check if Stata instance is ready to receive a job (running and not busy)
#' @param id An object of S3 class 'StataID' generated by \code{\link[RStataLink]{startStata}}
#' @param timeout Seconds to wait for Stata to respond. Default: 1.
#' @return \code{TRUE} or \code{FALSE}
#' @export
isStataReady <- function(id, timeout=1) {
	stopifnot(class(id)=='StataID',
			  is.numeric(timeout), timeout>=0)
	code <- c(LETTERS, letters, 0:9) %>%
		sample(10, TRUE) %>%
		paste(collapse="")
	log <- doInStata(id,
					 'di "' %++% code %++% '"',
					 timeout=timeout,
					 results=NULL)$log
	glob2rx('*' %++% code %++% '*') %>%
		grepl(log) %>% any
}

#' Open a Stata instance in a local server-like mode to be used by R through
#' \code{\link[RStataLink]{doInStata}}
#' 
#' A wrapper around Stata ``server'' code
#' @param timeout Seconds to wait for the response/confirmation from Stata. Default: 60.
#' @param start_cmd A string specifying a system command line to start Stata, e.g.: on Windows OS
#' \code{'"C:\\\\Program Files\\\\Stata14\\\\StataMP.exe"'}.
#' Default: the contents of option "statapath" obtined with \code{getOption('statpath')}.
#' @param compath A path to a directory where the R<->Stata information exchange
#' sub-directory should be created. Default: \code{\link{tempdir}()}.
#' @param exit_on_error601 Logical: should Stata be closed when the R--Stata data exchange
#' working directory disappears and Stata ``server'' stops
#' (\href{http://www.stata.com/search.cgi?query=601}{Stata error 601})? Default: \code{FALSE}.
#' @return An object of S3 class 'StataID' if Stata confirms that
#' the 'server' is ready, else an error.
#' @export
startStata <- function(timeout=60,
					   start_cmd=getOption('statapath'),
					   compath=tempdir(),
					   exit_on_error601=FALSE) {
	stopifnot(is.numeric(timeout), timeout>=0,
			  !is.null(start_cmd), is.character(start_cmd), length(start_cmd)==1,
			  is.character(compath), length(compath)==1,
			  is.logical(exit_on_error601), length(exit_on_error601)==1)
	repeat {
		id <- c(LETTERS, letters, 0:9) %>%
			sample(3, TRUE) %>%
			paste(collapse="")
		path <- compath %++% '/' %++% id
		result <- dir.create(path)
		if (result) break
	}
	stata_server_code <- c(adoFilesCode,
						   stataServerCode) %>%
		paste(collapse='\n') %>%
		multiGsub(list(
			# '<<<lstrfun.ado>>>', ado_path %++% 'lstrfun.ado',
			# 			'<<<mygen.ado>>>', ado_path %++% 'mygen.ado',
						'<<<ID>>>', id,
						'<<<CD>>>', path,
						'<<<exit_on_error601>>>', as.character(exit_on_error601)))
	stata_server_code_file <- tempfile(fileext='.do')
	cat(stata_server_code, file=stata_server_code_file)
	suppressWarnings(system(start_cmd %++% ' do "' %++% stata_server_code_file %++% '"',
							wait=FALSE))
	ID <- path
	class(ID) <- 'StataID'
	names(ID) <- id
	attr(ID, 'exit_on_error601') <- exit_on_error601
	if (isStataReady(ID, timeout) %>% not) stop('Starting Stata  failed.') else
		message('Stata "server" started successfully.')
	ID
}

#' Stop (close) Stata instance
#' 
#' A convenience wrapper around Stata code \code{exit, STATA}.
#' @param id An object of S3 class 'StataID' generated by \code{\link[RStataLink]{startStata}}.
#' @param clear Logical. Should the data in Stata memory be discarded
#' (i.e. Stata code \code{exit, STATA clear}). Default: \code{FALSE}.
#' @return \code{NULL} or error if there is unsaved data in Stata memory and
#' \code{clear=FALSE}.
#' @export
stopStata <- function(id, clear=FALSE) {
	stopifnot(class(id)=='StataID',
			  is.logical(clear), length(clear)==1)
	doInStata(id, 'exit, STATA ' %++% if (clear) 'clear', timeout=3) %>%
		extract2('log') %>%
		equals('no; data in memory would be lost') %>%
		any -> problem
	if (problem)
		stop('\nStata error:\n no; data in memory would be lost\n r(4);\n',
			 'Use argument clear=TRUE in stopStata()\n',
			 'if you want to discard the data in Stata memory.\n')
}
